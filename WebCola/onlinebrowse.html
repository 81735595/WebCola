<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Incremental exploration of a large graph</title>
<style>
@import url(style.css);

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .8;
}

</style>
</head>
<body>
    <h1>Online Graph Exploration</h1>
    <p>Red nodes are incomplete.  Click on them to expand their neighbours.</p>
<script src="d3.v3.js"></script>
<script src="pqueue.js"></script>
<script src="shortestpaths.js"></script>
<script src="vpsc.js"></script>
<script src="descent.js"></script>
<script src="cola.js"></script>
<script>
    var width = 960,
        height = 500;

    var color = d3.scale.category20();

    var cola = cola.d3adaptor()
        .linkDistance(60)
        .size([width, height]);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var edgesLayer = svg.append("g");
    var nodesLayer = svg.append("g");

    var modelgraph, viewgraph = { nodes: [], links: [] };

    d3.json("graphdata/biological.json", function (error, g) {
        modelgraph = g;
        var startNode = getNode("79");
        addViewNode(startNode);
        refocus(startNode);
        update();
    });

    function refocus(focus) {
        modelgraph.links.forEach(function (l) {
            var u = modelgraph.nodes[l.source], v = modelgraph.nodes[l.target];
            if (u === focus && !inView(v)) addViewNode(v, focus);
            if (v === focus && !inView(u)) addViewNode(u, focus);
        });
        viewgraph.links = [];
        viewgraph.nodes.forEach(function (v) {v.colour = "blue"});
        modelgraph.links.forEach(function (l) {
            var u = modelgraph.nodes[l.source], v = modelgraph.nodes[l.target];
            if (inView(u) && inView(v)) viewgraph.links.push({ source: u, target: v });
            if (inView(u) && !inView(v)) u.colour = "red";
            if (!inView(u) && inView(v)) v.colour = "red";
        });
    }

    function inView(v) {
        return typeof v.viewgraphid !== 'undefined';
    }

    function addViewNode(v, startpos) {
        v.viewgraphid = viewgraph.nodes.length;
        if (typeof startpos !== 'undefined') {
            v.x = startpos.x;
            v.y = startpos.y;
        }
        viewgraph.nodes.push(v);
    }

    function getNode(name) {
        var v, i = modelgraph.nodes.length;
        while (i--) if ((v = modelgraph.nodes[i]).name == name) return v;
        return null;
    }

    function click(node) {
        if (node.colour == "blue") return;
        var focus = getNode(node.name);
        refocus(focus);
        update();
    }

    function zoomImage(img, scale) {
        d3.select(img)
            .transition()
            .attr("width", function (d) { return scale * d.width; })
            .attr("height", function (d) { return scale * d.height; });
    }

    function update() {
        cola.nodes(viewgraph.nodes)
            .links(viewgraph.links)
            .start();

        var link = edgesLayer.selectAll(".link")
            .data(viewgraph.links);

        link.enter().append("line")
            .attr("class", "link")
            .style("stroke-width", 2);

        link.exit().remove();

        var node = nodesLayer.selectAll(".node")
            .data(viewgraph.nodes, function (d) { return d.viewgraphid; });

        var enter = node.enter().append("g")
            .attr("class", function (d) { return "node" + ('image' in d ? ' imagenode' : '') });

        nodesLayer.selectAll(".imagenode")
            .attr("class", "node")
            .append("image")
            .attr("xlink:href", function (d) {
                var url = "graphdata/" + d['image'] + ".gif";
                var simg = this;
                var img = new Image();
                img.onload = function () {
                    d.width = this.width / 4;
                    d.height = this.height / 4;
                    simg.setAttribute("width", d.width);
                    simg.setAttribute("height", d.height);
                }
                img.src = url;
                return url;
            })
            .on("mouseover", function () { zoomImage(this, 4) })
            .on("mouseout", function () { zoomImage(this, 1) });
        
        enter.append("circle")
            .attr("r", 7)
            .call(cola.drag)
            .on("click", function (d) { click(d) });

        node.style("fill", function (d) { return d.colour; })
            .append("title")
            .text(function (d) { return d.label; });

        cola.on("tick", function () {
            link.attr("x1", function (d) { return d.source.x; })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; });

            node.attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });
        });
    }

</script>
<p>
    This example introduces the notion of a "model" graph and a "view" graph.  The model graph is too large to sensibly display in one go.
    Instead we begin with just a small neighbourhood showing in the view graph which is bound to SVG visuals following the usual
    D3 pattern.  The red nodes have neighbours in the model graph
    that are not shown in the view graph.  Clicking on a red node causes its invisible neighbours to be added to the view and
    we use D3's enter/exit selections to update the display as usual.
    </p><p>
    The stability of WebCoLa layout makes this type of dynamic graph layout much less chaotic than is possible with the D3 force layout.
</p>
</body>
</html>
